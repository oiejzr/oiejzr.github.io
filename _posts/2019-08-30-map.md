---
layout: post
title: '洛谷2019PJ #4 图论初步'
subtitle: '假设你是诸葛孔明，那自然是聪明绝顶。有人心里悄悄想了一个数，这个数在[1,1024]范围内。你可以猜一个数，此人会马上告诉你，你猜的数是大了、小了还是正好。'
date: 2019-08-30
categories: 公告
cover: 'http://on2171g4d.bkt.clouddn.com/jekyll-theme-h2o-postcover.jpg'
tags: OI 基础数据结构 图论 算法
---
## 4.1 树
### 4.1.1 基础性质
![nldfKS.png](https://s2.ax1x.com/2019/09/07/nldfKS.png)
- 树是一对多的关系，一个父亲有多个孩子
- 层次性
- 递归定义
- 边数=点数-1
- 树上两点之间路径唯一，不存在环
![nlw0zV.png](https://s2.ax1x.com/2019/09/07/nlw0zV.png)

### 4.1.2 基本术语
- 深度：选定根节点后，这棵树有几层
- 节点的度：这个节点往外连了几条边
- 子节点（孩子），父节点（父亲），兄弟节点（同父亲的孩子）
- 叶子节点：没有孩子的节点

### 4.1.3 二叉树
每个节点最多只有两个子节点。

二叉树是一棵有序树，换而言之左儿子和右儿子一般而言是不能随便交换的。

- 二叉树的第i层有最多$2^{i-1}$个节点
- 深度为k的二叉树最多有$2^k-1$个节点（满二叉树（每个节点有且只有两个子节点）的节点数）
- 将一棵满二叉树（每个节点有且只有两个子节点）逐层编号，编号为i的节点的两个子节点的编号为$2\times i$与$2\times i+1$
![nlwfRx.png](https://s2.ax1x.com/2019/09/07/nlwfRx.png)

### 4.1.4 存储一个树
可以建立数组存储节点，每个节点后加动态数组以存储
其连向的节点

e.g.如图
![nlwHdH.png](https://s2.ax1x.com/2019/09/07/nlwHdH.png)
![nlwxQf.png](https://s2.ax1x.com/2019/09/07/nlwxQf.png)
代码实现:
```cpp
const int N = 1e5 + 5;
vector <int> G[N]; //N个int类型的vector
void addedge(int u, int v) //记录两条边的关系
{
	G[u].push_back(v); //u是v儿子/爸爸
	G[v].push_back(u); //v是u儿子/爸爸
}
```
如果要存入边权，怎么办？

代码实现:
```cpp
struct Edge
{
	int v, w; //指向边v的边权为w
};
Edge make_Edge(int v, int w) //
{
	Edge cur;
	cur.v=v;
	cur.w=w;
	return cur;
}
vector <Edge> G[N];
void addedge(int u, int v, int w) //记录带边权w的双边关系
{
	G[u].push_back(make_Edge(v,w)); //u是v儿子/爸爸
	G[v].push_back(make_Edge(v,w); //v是u儿子/爸爸
}
//等同于如下写法，且包含于头文件 #include<pair> ，不建议使用
vector <pair<int, int>> G[n]; //一坨vector里有两个变量
void addedge(int u, int v, int w) 
{
	G[u].push_back(make_pair(v,w)); 
	G[v].push_back(make_pair(v,w); 
}
```
### *4.1.5 前向星 
比用vector写的又臭又长还看不懂为什么要做笔记

### 4.1.6 二叉树的遍历
![nl0Y6K.png](https://s2.ax1x.com/2019/09/07/nl0Y6K.png)
【先序遍历】根->左->右

深度优先，遇到一个就存入一个

e.g. 1,2,4,5,3,6


【中序遍历】左->根->右

深度优先，走到末尾再存入，回溯

e.g. 4,2,5,1,6,3


【后序遍历】左->右->根

深度优先，根节点最后存入

e.g. 4,5,2,6,3,1


容易发现特点，先序将根节点置于第1个，后序将根节点置于最后一个，中序用根节点将序列分为两部分，左边为左子树，右边为右子树

### 4.1.7 二叉排序树
如果一棵树的中序遍历会保证有序，那么我们称这种树为二叉排序树。
换而言之，二叉排序树满足 左<根<右 这一性质。
代码实现：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10;
struct Node
{
	int val, lc, rc, w; //val=当前节点值， lc,rc分别为左子树和右子树，w记录当前节 
                          点重复的数量
};
Node T[N];
int n,cnt,a[N];

void ins (int o, int v)
{
	if (T[o].val == 0)
	{
		T[o].val = v;
		T[o].w++;
		return 0;
	}
	if (T[o].val == v)
	{
		T[o].w++;
		return 0;
	}
	if (v < T[o].val)
	{
		if(T[o].rc == 0)
		{
			T[o].rc = cnt++;
		}
		ins(T[o].rc, v);
	}
	if (v > T[o].val)
	{
		if(T[o].rc == 0)
		{
			T[o].rc = cnt++;
		}
		ins(T[o].rc, v);
	}
}
void dfs(int o)
{
	if (T[o].val == 0)
	{
		return 0;
	}
	if (T[o].lc != 0)
	{
		dfs (T[o].lc);
	}
	for (int i=1;i<=T[o].w;i++)
	{
		printf ("%d ", &T[o].val);
	}
	if(T[o].rc != 0)
	{
		dfs (T[o].rc);
	}
}
int main()
{
	scanf ("%d", &n);
	cnt=1;
	for (int i=1;i<=n;i++)
	{
		scanf("%d", &a[i]);
	}
	for (int i=1;i<=n;i++)
	{
		ins(i, a[i]);
	}
	return 0;
}
```

### 4.1.8 树的重心
如果我们挑选某个节点作为树的根节点的话，剩下的各个子树大小会相对接近，这就是树的重心。
![nl0dTH.png](https://s2.ax1x.com/2019/09/07/nl0dTH.png)
e.g.

以1为重心，左：右 = 3：2

以2为重心，左：中：右 = 1：1：3

以3为重心，左：右 = 4：1

以4为重心，左：右 = 0：5

以5为重心，左：右 = 5：0

以6为重心，左：右 = 5：0

∴重心=1


重心的性质：
- 性质 1 ：树中所有点到某个点的距离和中，到重心的距离和是最小的，如果有两个重心，到他们的距离和一样。
- 性质 2 ：把两棵树通过某一点相连得到一颗新的树，新的树的重心必然在连接原来两棵树重心的路径上。
- 性质 3 ：一棵树添加或者删除一个节点，树的重心最多只移动一条边的位置。

由 性质1 知，令最大的节点尽可能小，则当前节点为重心，记为性质P。

叶子一般不是重心。


找到中心的方法：

    ①dfs一次，算出以每个点为根的子树大小。

    ②记录以每个结点为根的最大子树的大小。

    ③根据 性质P 判断：如果以当前结点为根的最大子树大小比当前根更优，更新当前根。

代码实现：
```cpp
int f[N]; //若以i为重心，那么i的最大子树大小为f[i]
int size[N], n; //size是子树大小
void getrt (int u, int fa)
{
	size[u] = 1;
	f[u] = 0;
	for (int i = 1;i <= G[u].size();i++)
	{
		int v = G[u][i];
		if(v == fa)
		{
			continue;
		}
		getrt(v, u);
		size[u] += size(v);
		f[u]=max(f[u], size[v]);
	}
	f[u] = max (f[u], sum - size[u]); //总点数n
	if(f[u] < f[rt])
	{
		rt = u;
	}
}
```

### 4.1.9 树的直径

定义：树上最长的一条树链。

性质：从任意一点到树上最远的点一定是直径的一端点。

求直径的方法：

(A) DFS

由性质可知，可以先取一点，DFS该点的最远点为直径一端点。

再重复一遍DFS，求出另一个端点，即可知道答案

(B) DP

听不懂，直接复制。

如果我们枚举树上一个点，可以发现经过这个点的最长链一定是由从这个节点出发向子树的最长链+不在同一个子树的次长链组成。

## 4.2 图
### 4.2.1 图的概念

图上节点的关系是多对多。

概念与术语：

节点x的入度f(x)：有f(x)个节点可以直接连向x

节点x的出度g(x)：有g(x)个节点可以由x直接连向
![nl0cX8.png](https://s2.ax1x.com/2019/09/07/nl0cX8.png)

【自环】
一个连接到自身的节点。
▲自环只能是有向图。
![nl0R0g.png](https://s2.ax1x.com/2019/09/07/nl0R0g.png)

【连通图】
图内的每一个节点都互相直接或间接连接的图是连通图，
反之为非连通图。
![nl0W7Q.png](https://s2.ax1x.com/2019/09/07/nl0W7Q.png)

图内的每一个节点都可以到达其它节点的图是强连通图。

可以分成两份使得两边对节点相连但同节点不相连的图是二分图。

重边：两点之间有多条边

### Q4.2.a 【图论的起源】例题
能否一笔画下图？
![nl0HXT.png](https://s2.ax1x.com/2019/09/07/nl0HXT.png)

- ①图必须是一个联通图
- ②定义遍历路径起点，终点，及之间的过路点
- ③过路点应该是有进有出的点，因此，过路点的度数应该是偶数。
- ④因此，那么如果起点和终点重合，奇点个数=0

如果起点和终点不重合，那么奇点个数=2

不满足上述两种情况的任何一种的话，都不可能存在一笔画的路径。
- ⑤该图有4个奇点，不可一笔画。

后人为了纪念欧拉，把这种路径称作图的欧拉路。如果起点终点重合，这种路径被称作欧拉回路。

### 4.2.2 邻接矩阵存储图
- 定义a[N][N]为一个二维数组
- 如果u和v之前有边相连a[u][v]=1，反之为0

### 4.2.3 图的遍历
满足的规则：
不能走已经遍历过的点
```cpp
vector <int> g[n]
void addedge(int u, int v) //记录两条边的关系
{
	G[u].push_back(v); //u是v儿子/爸爸
	G[v].push_back(u); //v是u儿子/爸爸
}
int vis[n];
void dfs(int u)
{
	vis[u]=1;
	for(int i=1;i<=g[u];i++)
	{
		int v=g[u][i];
		if(vis[v]==1)
			continue;
		dfs(v);
	}
}
```
### Q4.2.b 【例题】UOJ拯救计划

小O和小I一直喜欢打 UOJ 的比赛，然而等了半个丁酉年却也没能等到下一次比赛。眼看着 NOI 即将到来，他们决定一探究竟，找出 UOJ 沉寂的真正原因！ 

终于有一天，他们得知 UOJ 的管理层全都被两个一心想摧毁 OI 界的大魔王——滴滴诶柳和不响公座给封印起来。 

这两个大魔王向来战略上联手对敌，战术上分工合作。每次滴滴诶柳首先给 oier 带来一堆麻烦；接着不响公座用超声波对 oier 进行催眠，降低 oier 们的反抗效率；关键时候滴滴诶柳又进行反向催眠，让 oier 拼命反击筋疲力尽。两个魔王轮流值班，有着充足的休息时间，而他们的对手却受到无间断攻击。最后随着时间的推移，oier 们的体力到了最低点时，不响公座放出大招，将 oier 封印起来。 

要想拯救 UOJ，必须打败这两个魔王。小O和小I查阅资料，终于找到了获胜的方法——OI 阵。 

首先，他们需要召集 n 名 oier 布阵，联手对敌。为了高效地反击滴滴诶柳，他们决定让 nn 名 oier 站成一张图的样子，每个 oier 负责应对自己和相邻 oier 所受到的攻击。当一个 oier 受到攻击时，图中相邻的 oier 及时支援。 

同时他们意识到，当一个 oier 身边有同校的 oier 时，不响公座攻击的时候他们会聊起天来从而阵法被破；而反之，如果身边的人都不熟悉，则会产生表现欲，有效抗住不响公座的超声波攻击。因此他们要求，图中任意两个相邻的 oier 来自不同的学校。 

现在已知这张图的构成。该图具有 n个点 m条边，节点编号依次为 1,…,n。同时共有 k 个学校，由于拯救 UOJ 人人有责，故每个学校都有无数的 oier 愿意出力。 

小O想要知道有多少种布阵方式，但是鉴于小I最多只能数到 5（他学会的最大的数字来自于“一二三四五上山打老虎”），因此小O决定输出方案数模 6。 

两个布阵方式被认为是不同的当且仅当存在一个节点i使得这两种布阵方式中守卫该节点的 oier 来自不同的学校。

### Q4.2.b 【分析】UOJ拯救计划
分析得出 $$Answer=\sum_{i=1}^k A_k^i\times 刚好使用i个颜色的方案数目 mod 6$$
又因为当$i>=3时$，对答案的贡献为$6|A_k^i=0$，不予考虑。
此时， $\begin{cases}
i=1,m=0(舍)\\
i=2,求图的二染色方案数
\end{cases}$
即判断整张图是否二分图
分析得出$Answer=2^{连通块个数}$
。

## 4.3 恶心的图
### 4.3.1 主要内容
- 拓补排序
- 最小生成树
- 最短路

### 4.3.2 邻接表存储图（更恶心的）
邻接表：

保存每个点相连的边，具体实现方式有多种。

- 边多使用结构体定义，
Edge {int from, to, dist;}
- 若只需要保存边的终点可以用int只保存to
vector(1_vector.cpp)：
vector<Edge> g[MAXN];
- g[i]是一个vector，保存和点i相连的边
插入时直接将边push_back进起点的vector中，遍历时直接使用iterator，若支持C++11还可以使用auto关键字。

代码很短，常数在STL上，跑的飞快，从未被卡。

### 4.3.3 预存储
在图论中有时需要表示边权，对于未连通的边，可以将其边权视为无限大

在编程时需要将其赋值为一个数据范围外的特殊值


-1：非负权值时通用，但是每次需要做特判，可以memset

0x7fffffff：理论上最大，但是相加会溢出，仍然要特判

0x3fffffff：较大，好处是两个INF相加不会溢出，min(INF, INF+INF)=INF

0x3f3f3f3f：较大，相加不会溢出，可以memset，最常使用

0x3f3f3f3f3f3f3f3fLL：注意数据范围，图论题常常需要long，对应的为该值

### Q4.3.a 有向无环图（DAG）的判定
![nlsjr6.png](https://s2.ax1x.com/2019/09/07/nlsjr6.png)

### 4.3.4 拓扑排序

对有向无环图的顶点进行排序，结果要求

每个顶点出现且仅出现一次

对于顶点对(u,v)，若排序后u在v前，则不存在v到u的路径

可以理解为，能够到达某个顶点u的所有点都在u前面出现的一种访问顺序

一般是随着排序过程处理节点的信息，不需要显式得出结果

拓扑排序对于环无法执行，对于无向图没有意义。

- ①首先在建图时记录每个点的入度
- ②建立一个队列，把接下来需要访问的点加入队列
- ③最开始时所有入度为0的点都可以访问，加入队列
- ④依次从队列中取出每个点u，枚举其出边，边的终点设为v
此处进行各种u->v的信息更新
- ⑤因为u信息已经计算过了，相当于从图中删去u，将其v入度-1
- ⑥此时v若入度为0则说明前置信息处理完成，加入队列
如图为例
![nlyEsP.png](https://s2.ax1x.com/2019/09/07/nlyEsP.png)
- 1)	①的入度为0，把①加入队列
- 2)	在去掉①之后，②的入度为0，把②加入队列
注意此时⑥的入度为1
- 3)	③的入度此时为0，加入队列
- 4)	④无法加入队列，⑤的入度为0，加入队列
- 5)	④的入度此时为0，加入队列
- 6)	⑥的入度此时为0，加入队列
代码实现：
```cpp
int ind[MAXN];
int d[MAXN];
int q[MAXN], qhead = 0, qtail = 0;
struct Edge {
	int from, to dist;
	Edge() {}
	Edge(int _from, int _to, int _dist): from(_from), to(_to), dist(_dist) {}
void topo() {
    for (int i = 1; i <= n; i++) {
        if (!ind[i]) q[qtail++] = i;
    }

    while (qhead != qtail) {
        int now = q[qhead++];
        for (int i = he[now]; i; i = ne[i]) {
            Edge &e = ed[i];
            d[e.to] = max(d[e.to], d[now] + 1);
            if (!--ind[e.to]) q[qtail++] = e.to;
        }
    }
}
```

### Q4.3.b 【例题】信息传递（P2661，拓扑排序做法）
有n个同学（编号为1到n）正在玩一个信息传递的游戏。在游戏里每人都有一个固定的信息传递对象，其中，编号为i的同学的信息传递对象是编号为T[i]的同学。

游戏开始时，每人都只知道自己的生日。之后每一轮中，所有人会同时将自己当前所知的生日信息告诉各自的信息传递对象（注意：可能有人可以从若干人那里获取信息， 但是每人只会把信息告诉一个人，即自己的信息传递对象）。当有人从别人口中得知自己的生日时，游戏结束。请问该游戏一共可以进行几轮？
### Q4.3.b 【分析】信息传递（P2661，拓扑排序做法）

可以知道模型为基环内向树

基环内向树：环上的点的出边一定指向环上的下一个点，其它点指向关系是一颗树，树根指向环上的点

（题目中可能不止一颗基环内向树）

可以先利用拓扑排序删去树，最后计算环的长度

### Q4.3.c 【例题】车站分级（P1983，提高+省选-）

一条单向的铁路线上，依次有编号为1, 2, …, n的 n个火车站。每个火车站都有一个级别，最低为 1 级。现有若干趟车次在这条线路上行驶，每一趟都满足如下要求：如果这趟车次停靠了火车站 x，则始发站、终点站之间所有级别大于等于火车站 x 的都必须停靠。（注意：起始站和终点站自然也算作事先已知需要停靠的站点）

例如，下表是 5 趟车次的运行情况。其中，前 4 趟车次均满足要求，而第 5 趟车次由于停靠了 3 号火车站（2 级）却未停靠途经的 6 号火车站（亦为 2 级）而不满足要求。
![nlygoD.png](https://s2.ax1x.com/2019/09/07/nlygoD.png)
现有 m 趟车次的运行情况（全部满足要求），试推算这 n 个火车站至少分为几个不同的级别。
### Q4.3.c【分析】车站分级（P1983，提高+省选-）

考虑一条火车线路会带来什么信息

经过的站点编号大于未经过的站点

每个站点建立一个节点，每个“大于”建立一条有向边

问题转化为有向无环图上的最长链

记录l[i]为终点为i的最长链，l[i]=max{l[j]} + 1, (j, i) ∈ E

类似DP的式子，为了保证计算顺序需要按照拓扑序遍历

#### **连边太慢**
- 考虑将每条火车经过的站点中优先级最低的节点作为这条火车的优先级
- 若两条火车运行区间有重叠，考虑重叠的这部分区间
- 若经过站点不相同，则一定是某条优先级较高火车经过的站点的包含另一条的站点
- 因此将每条火车建点，仍然将大于关系建边求最长链
### 4.3.5 偏序关系*

从自反性、对称性、传递性三个方面考虑集合的某个关系
![nlyOYQ.png](https://s2.ax1x.com/2019/09/07/nlyOYQ.png)
//搬运旧工程

这类关系被称为偏序关系，可以将集合中元素建点，将偏序关系建有向边转化为图论问题，然后通过拓扑排序等有向图算法求解。
## 4.4 最小生成树
### 4.4.1 名词解释
> V:节点
> E:边

- 子图：图G'称作图G的子图如果V(G') ⊆ V(G)以及E(G') ⊆ E(G)。
也就是从原图中选出一些点以及和一些边组成的新的图
- 生成子图：指满足条件V(G')=V(G)的G的子图G'。
也就是选出所有的点和一些边组成的新的图，生成树则是指子图G'是一颗树
- 最小生成树：对于带权图，权值和最小的生成树
- 最小瓶颈生成树：对于带权图，最大权值最小的生成树
--最小生成树一定是最小瓶颈生成树--
![nl6CwT.png](https://s2.ax1x.com/2019/09/07/nl6CwT.png)

可以使用Prim算法或者Kruskal算法，复杂度均为O(mlogn)

推荐使用后者，无需建图

### 4.4.2 Prim算法实现求最小生成树

-	随意选取一个点作为已访问集合的第一个点，并将所有相连的边加入堆中
-	从堆中找到最小的连接集合内和集合外点的边，将边加入最小生成树中
-	将集合外点标记为已访问，并将相连边加入堆
-	重复以上过程直到所有点都在访问集合中

流程图：
![nl6Vp9.png](https://s2.ax1x.com/2019/09/07/nl6Vp9.png)
代码实现：
```cpp
int map[N][N], low[N], visited[N], n;  //map数组存储图的邻接矩阵形式的权值
               //low数组记录每2个结点间最小权值，visited数组标记是否已被访问

int prim()
{
	int i, j, pos, min;   // pos为位置
	int result = 0;
 
	memset(visited, 0, sizeof(visited));
	visited[1] = 1, pos = 1;  // 从某点开始， 分别标记和记录该点
 
	for (i = 1; i <= n; i++)// 第一次给low数组赋值
		if(i != pos)
			low[i] = map[pos][i];
		
	printf("%d->", pos);//
 
	for (i = 1; i < n; i++)// 再运行n-1次(给low数组赋值的操作)
	{
		// 找出最小权值并记录位置
		min = MaxInt;  
		for (j = 1; j <= n; j++)
			if(visited[j] == 0 && min > low[j])
			{
				min = low[j];
				pos = j;
			}
		printf("%d->", pos);
		result += min;// 最小权值累加
		visited[pos] = 1; // 标记该点
 
		//更新权值
		for (j = 1; j <= n; j++)
			if(visited[j] == 0 && low[j] > map[pos][j])
				low[j] = map[pos][j];
	}
 
	return result;
}
```
### 4.4.3 Kruskal算法实现求最小生成树
- 将边按照权值排序
- 依次枚举每一条边，若连接的两点在已选中集合图中不连通则加入最小生成树
- 使用并查集维护连通性

流程图：
![nl6mOx.png](https://s2.ax1x.com/2019/09/07/nl6mOx.png)

代码实现：
```cpp
struct UnionSet {  //并查集
    int f[MAXN];
    UnionSet(int n) {
        for (int i = 1; i <= n; i++) {
            f[i] = i;
        }
    }
    UnionSet(){}

    void uni(int x, int y) {
        f[find(x)] = find(y);
    }

    bool query(int x, int y) {
        return find(x) == find(y);
    }

    int find(int x) {
        return f[x] == x ? x : (f[x] = find(f[x]));
    }

} us;

void kruskal() {
    sort(edges, edges+m); 
    us = UnionSet(n);
    for (int i = 0; i < m && etop < n * 2 - 1; i++) {
        Edge &e = edges[i];
        if (!us.query(e.from, e.to)) {
            insert(e.from, e.to, e.dist);
            insert(e.to, e.from, e.dist);
            us.uni(e.from, e.to);
        }
    }
}
```
## 4.5最短路
### 4.5.1定义
求从s到t权值和最小的路径

- Floyd算法：
多源最短路，求出所有点对的最短路长度
时间复杂度：O(n³)
- Dijkstra算法：
单源最短路，求出某个点s到所有点的最短路长度
时间复杂度：O(n²)/O(mlogn)
无法处理负权
- SPFA算法，即队列优化的Bellman-Ford算法：
单源最短路，求出某个点s到所有点的最短路长度
时间复杂度：声称为O(m)，最坏O(nm)，容易卡到最坏
可以处理负权边，可以判断负权环

（有负权时只能选择SPFA）
（无负权时一般只使用Dij）
### 4.5.2 Floyd算法
设d[i][j][k]为从i到j，仅通过编号为1~k的中间节点的最短路径距离

状态转移方程：
d[i][j][k] = min(d[i][j][k-1], d[i][k][k-1] + d[k][j][k-1])

初始值d[i][j][0]为两点之间边权值，未连通为INF
从1到n枚举k，然后枚举(i, j)

为了方便可以不开第三维，在原地迭代

代码实现：
```cpp
int d[MAXN][MAXN];

void floyd() {
    for (int k = 1; k <= n; k++) {
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                if (i != j && i != k && j != k)
                    d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
            }
        }
    }
}
```
### 4.5.3单源最短路
维护一个dis[MAXN]数组，dis[i]代表s到i的最短路径长度
dis[s]=0,其他为INF

松弛操作：通过某条路径更新dis[v]的值
```cpp
if (dis[v] > dis[u] + e.dist) //e.dist即边(u, v)权
{
dis[v] = dis[u] + e.dist
}
```
尝试使用s到u的最短路加上边(u,v)的长度来更新s到v的最短路
### 4.5.4 SPFA算法

Bellman-Ford：对整张图进行n-1次松弛，每次枚举每条边进行松弛，最后一定能得出最优解

SPFA：在上述过程中避免无意义的松弛

只有成功的松弛操作才会对那个点产生影响，所以使用队列维护等待松弛的点，每次取出一个点进行松弛，对于所有松弛成功的点加入队列

		注意：进入队列的点不可再进入队列，否则挂

判负环：某个点松弛了第n次，说明有负环

流程图：
![nl6spj.png](https://s2.ax1x.com/2019/09/07/nl6spj.png)
![nl66cn.png](https://s2.ax1x.com/2019/09/07/nl66cn.png)

代码实现：
```cpp
bool inq[MAXN];
queue<int> q;
inline int spfa(int s, int t) {
    q.push(s);
    inq[s] = true;
    memset(d, 0x3f, sizeof(d));
    d[s] = 0;
    while (!q.empty()) {
        int now = q.front(); q.pop();
        inq[now] = false;
        for (int i = he[now]; i; i = ne[i]) {
            Edge &e = ed[i];
            if (d[now] + e.dist < d[e.to]) {
                d[e.to] = d[now] + e.dist;
                if (!inq[e.to]) {
                    q.push(e.to);
                    inq[e.to] = true;
                }
            }
        }
    }
return d[t] == INF ? -1 : d[t];
}
```
//无法理解代码

### 4.5.5 Dijkstra算法
起点作为已访问集合的第一个点，并更新相连的点的dis
- 找到未被访问的dis最小的点，标记访问，用这个点更新相连的点dis
- 重复上述过程直到所有的点均被访问


问题在于“找到未被访问的dis最小的点”这一步，两种不同的实现方法会带来两种复杂度

枚举每个点

当点u的距离更新时，将(dis[u], u)插入堆中，这样堆中可能有多个u，此时取出后面的点时，会发现u已经被访问过不再处理

流程图：
![nl6hAU.png](https://s2.ax1x.com/2019/09/07/nl6hAU.png)

代码实现：
```cpp
int d[MAXN];
bool vis[MAXN];
priority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > q;
int dijkstra(int s, int t){
    memset(d, 0x3f, sizeof(d));
    d[s] = 0;
    q.push(make_pair(0, s));
    while(!q.empty()){
        int now = q.top().second;
        q.pop();
        if(!vis[now]){
            vis[now] = true;
            for(int i = he[now]; i; i = ne[i]){
                Edge& e = ed[i];
                if(d[e.to] > d[now] + e.dist){
                    d[e.to] = d[now] + e.dist;
                    q.push(make_pair(d[e.to], e.to));
                }
            }
        }
    }
    return d[t] == INF ? -1 : d[t];
}
```
-	只要没负环 一律写Dijkstra
-	SPFA卡常数还有负环 -> 你疯了/出题人疯了

### 4.5.6 拆点
若求点权的最小路，需要将点拆为入点和出点，中间连边权为原点权的边。
### Q5.5.a 【例题】邮递员送信（P1629）
#### **题目描述**
有一个邮递员要送东西，邮局在节点1.他总共要送N-1样东西，其目的地分别是2~N。由于这个城市的交通比较繁忙，因此所有的道路都是单行的，共有M条道路，通过每条道路需要一定的时间。这个邮递员每次只能带一样东西。求送完这N-1样东西并且最终回到邮局最少需要多少时间。

#### **输入格式**
第一行包括两个整数N和M。

第2到第M+1行，每行三个数字U、V、W，表示从A到B有一条需要W时间的道路。 满足1<=U,V<=N,1<=W<=10000,输入保证任意两点都能互相到达。

#### **数据规模**
对于30%的数据，有1≤N≤200;

对于100%的数据，有1≤N≤1000,1≤M≤100000。

#### **输出格式**
输出仅一行，包含一个整数，为最少需要的时间。