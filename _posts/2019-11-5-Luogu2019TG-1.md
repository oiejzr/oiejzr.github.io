---
layout: post
title: '洛谷2019TG #1 初级数据结构-课时1'
subtitle: ''
date: 2019-11-05
categories: OI
cover: 'http://on2171g4d.bkt.clouddn.com/jekyll-theme-h2o-postcover.jpg'
tags: Luogu.2019.TG
---


## -1- 课时内容
- 单调栈
- 单调队列
- 差分与前缀和

## -2- 单调栈

### 定义

「什么是单调栈啊？」

「就是单调的栈啊。」

单调栈指维护**栈内与出栈序列**单调递增/递减的栈.

- 「如何维护单调栈？」
    - 在压入新的元素前，弹出所有比它小/大的栈内元素.

- 「单调栈的时间复杂度？」
    - O(n).容易发现，每个元素至多被压入/弹出一次.

- 「弹出的元素栈里没有了怎么办？」
    - 弹出去了啊.

### 示例

有一组数据 `10 3 7 4 12`. 试维护单调递增栈.

当前入栈的元素 | 当前弹出的元素 | 栈内 | 弹出的序列 | 注释
:-: | :-: | -: | :- | :-
10 | / | 10 | / | / 
3 | / | 3 10 | / | /
7 | 3 | 7 10 | 3 | 3<10,pop(3)
4 | / | 4 7 10 | 3 | /
12 | 4 7 10 | 12 | 3 4 7 10 | 4<7<10<12,pop(4,7,10)

最后pop(12)，得到出栈序列 3 4 7 10 12.

可以看到，栈内元素始终保持从栈底到栈顶单调递增.

同时，出栈序列单调递增.

### 例题 [洛谷P3467](https://www.luogu.org/problem/P3467)

>【题干】
>
>n个矩形，排成一排. 给出矩形高，现在希望用尽量少的矩形海报Cover住它们.

显然，如果有两个等高的相邻或非相邻矩形，那么可以较原来n张的基础上节省一张海报.

期望得分: *0pts*

- 「为什么？」
    - 如果两个非相邻矩形中间有比它矮的，叫节省一张？

可以建立单调栈，高度入栈，维护单调递增性. 若是入栈时有比当前栈顶小的，就弹出. 若是遇到与栈顶相等的，ans++.

最终答案 = n-ans.

期望得分: *100pts*

关键代码:
```cpp
for(int i=1; i<=n; i++)
{
    scanf("%d%d", &p, &cac);
    while(cac <= h[top])
    {
        if(cac == h[top])
        {
            ans++;
        }
        top--;
    }
    h[++top] = cac;
}
printf("%d", n-ans);
```

## -3- 单调队列

### 定义

「什么是单调队列啊？」

「就是单调的队列啊。」

单调队列指维护**队内与出栈序列**单调递增/递减的队列.

- 「如何维护单调队列？」
    - 在压入新的元素前，弹出所有比它小/大的队内元素.

- 「单调队列的时间复杂度？」
    - O(n).容易发现，每个元素至多被压入/弹出一次.

- 「弹出的元素队列里没有了怎么办？」
    - 弹出去了啊.

（好水

### 优先队列

有很多种实现优先队列的方式，最常见的就是堆.

最常见的堆就是二叉堆，`C++`中`priority_queue`定义了一个以权值为优先级的堆.

`#include<queue>`

`priority_queue <数据类型> q;`

这样就声明了一个优先队列.

优先队列初始默认是权值大优先级高（大根堆）.

声明成权值小优先级高（小根堆）：

`priority_queue<int,vector<int>,greater<int> > q;`

### 例题 [洛谷P1090](https://www.luogu.org/problem/P1090)

>【题干】
>
>在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。
>
>每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过 n-1 次合并之后， 就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。
>
>因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为 11 ，并且已知果子的种类数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。
>
>例如有 33 种果子，数目依次为 11 ， 22 ， 99 。可以先将 11 、 22 堆合并，新堆数目为 33 ，耗费体力为 33 。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为 1212 ，耗费体力为 1212 。所以多多总共耗费体力 =3+12=15 。可以证明 1515 为最小的体力耗费值。

利用优先队列STL对果子重量进行排序.

关键代码:
```cpp
priority_queue <int, vector <int>, greater <int> > q;
int n, cac, x, y, ans;

int main()
{
	scanf("%d", &n);
	for(int i=1; i<=n; i++)
	{
		scanf("%d", &cac);
		q.push(cac);
	}
	while(q.size() >= 2)
	{
		x = q.top(); q.pop();
		y = q.top(); q.pop();
		ans += (x+y);
		q.push(x+y);
	}
	printf("%d", ans);
	return 0;
}
```

## -4- 差分与前缀和

### 定义

对于一个数列a[i]定义数组`pre[i]`为前`i`个数之和. 满足`pre[i] = pre[i-1] + a[i]`. 时间复杂度为O(n).

### 应用

- 区间[l,r]之和 = pre[r] - pre[l-1]
- 有n组操作，每次是将[l,r]中的数增加x，最后需要你输出这个数组.
    - 我们如果知道第一个数，和每一个数跟前一个数的差值是多少，我们就能还原出这个数组。那么我们可以先扫一遍把a[i]变成a[i]-a[i-1]。考虑到一次区间加对这个数组的影响：a[l]+=x;a[r+1]-=x；最后整体求一个前缀和即可。