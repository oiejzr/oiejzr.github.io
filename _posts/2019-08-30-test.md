---
layout: post
title: '洛谷2019PJ #3 递推, 递归与分治'
subtitle: '把n+1件东西放入n个抽屉，则至少有一个抽屉里放了两件或两件以上的东西。从另一个角度说，把n-1件东西放入n个抽屉，则至少有一个抽屉是空的。'
date: 2019-08-30
categories: 公告
cover: 'http://on2171g4d.bkt.clouddn.com/jekyll-theme-h2o-postcover.jpg'
tags: OI 算法 基础
---

## 3.2 递推
### 3.2.1 递推的本质
有些问题中，相邻两项或多项数字（或状态）之间存在某种关系，可以通过前一项或多项按照某一规律推出其后一项数字（或状态），或者是通过后一项或多项按照某一规律推出其前一项数字（或状态）。我们可将这种规律归纳成如下递推关系式：

- 找到初始状态
- 找到递推公式
- 开始循环算即可。
### Q3.2.a 【引入】斐波那契数列
递推关系式：
$$f[0]=0, f[1]=1$$
$$f[n]=f[n-1]+f[n-2]$$
### Q3.2.b 【例题】平面分割问题
平面内有n条直线，最多可以把这个平面划分成多少区域？
![nlNp1U.png](https://s2.ax1x.com/2019/09/07/nlNp1U.png)
考虑到，这条线如果跟之前的每一条直线都相交，就会产生n个新的区域。

那么，在第n次操作时，$f[n]=f[n-1]+n$

定义初值为$f[0]=1$.

可以用累加法化为$f[n]=\cfrac{n(n+1)}{2}$

同一平面内有$n(n≤500)$条直线，已知其中$p(p≥2)$条直线相交于同一点，则这$n$条直线最多能将平面分割成多少个不同的区域？
 
平面内有$n$条封闭曲线，任意两条封闭曲线交于两点，任意三条封闭曲线不交于一点，求划分出的区域数量

记$n$条曲线划分出来的区域数量为$f[n]$

$n$条曲线被前$n-1$条曲线分割成$2(n-1)$段弧线
每一段弧线又会将一个区域划分出两个区域，所以是比原来多了$2(n-1)$个区域
$$f[n]=f[n-1]+2(n-1)$$
通过喜闻乐见的累加法，我们得到了通项：
$$f[n]=n^2-n+2$$
### Q3.2.c 用递推的做法做DFS
如图，从点（0，0）走到点（x，y）一共有F（x，y）种走法
![nlUfRf.png](https://s2.ax1x.com/2019/09/07/nlUfRf.png)
用递推的语言说，定义f[x][y]为从(0,0)走到(x,y)的方案数

$$f[i][j] = f[i-1][j] + f[i][j-1]$$

## 3.3 组合计数
### 3.3.1 抽屉原理
把n+1件东西放入n个抽屉，则至少有一个抽屉里放了两件或两件以上的东西。从另一个角度说，把n-1件东西放入n个抽屉，则至少有一个抽屉是空的。

### 3.3.2 加法原理
如果完成事件A有n种方法，完成事件B有m种方法，那么完成两者之一有n+m种方法。

### 3.3.3 乘法原理
如果完成事件A有n种方法，完成事件B有m种方法，那么先完成A再完成B有n*m种方法。

### 3.3.4容斥原理
把多加的减掉，把多减的加上
画图理解
![nlUOJ0.png](https://s2.ax1x.com/2019/09/07/nlUOJ0.png)

### 3.3.5 排列组合
从n个数中有序地选出m个数的方案数是多少？
$$A(n,m)=n\times(n-1)\times…\times(n-m+1)=\frac{n!}{n-m!}$$
从n个数中无序地选出m个数的方案数是多少？
$$C(n,m)=\frac{A(n,m)}{m!}=\frac{n!}{m!(n-m)!}$$
$$C(n,m)=C(n-1,m)+C(n-1,m-1)$$
### 3.3.6 卡特兰数
- n对括号的括号序列数
- n个数的出栈序列
- n个点能构成多少种不同的二叉树
$$C(n)=\frac{2×(2n-1)}{(n+1)×C(n-1)}$$
$$C(n)=∑_{i=0}^{n-1}C(i)×C(n-i-1), n≥1$$
## 3.4 递归
### 3.4.1 递归的性质
一个递归定义必须是有确切含义的，也就是说一步比一步简单，最终是有终结的，决不能无限循环下去。比如上例中的$f(0)=a$，这种最简单的情况（终结条件），称为递归边界，它是递归定义必不可少的一部分。

递归和递推描述的过程非常相像，递归是倒着的，递推是顺着的。

### 3.4.2 递归的优化——记忆化递归
我们发现，递归比递推慢了很多很多很多

我们发现，对于一个值我们重复计算了多次，能不能把它记下来让它只算一次呢？
```cpp
int f[100005];
memset(f,-1,sizeof(f));
f[0]=0;f[1]=1;
int dfs(int x)
{
		if(f[x]!=-1) return f[x];
		else return f[x]=dfs(x-1)+dfs(x-2);
}
```
## 3.5 分治
### Q3.5.a 【引入】快速幂
考虑计算a^n,(n≤10^18)

分情况讨论：

- 在n∈偶数时, $a_n=a^{\frac{n}{2}}\times a^{\frac{n}{2}}$
- 在n∈奇数时, $a_n=a^{\frac{n}{2}}\times a^{\frac{n}{2}}\times a$
### Q3.5.b 【例题】归并排序
假设现在我们要对下标在[l,r]的部分排个序

那么我们先求出中点$m=(l+r)/2$,然后分别对[l,m],[m+1,r]考虑

然后我们考虑把已经有序的两段合并起来

由于这两段已经有序，所以用两个指针扫描下即可

e.g.序列X		1	3	6	7

			    i

	序列Y		2	3	5	6

			    j

序列ans为合并后的序列

∵X[i]<Y[j]

∴ans[p]=X[++i];

直到sizeof(x)==sizeof(y)==1,即给两个数比大小，执行后开始回溯合并操作

我们发现序列上的分治问题有一个很常见的套路：

把区间二分，先解决每个区间内的，再考虑跨越端点的

### Q3.5.c 【例题】P1115最大子段和
#### **题目描述**
给出一段序列，选出其中连续且非空的一段使得这段和最大。

#### **输入输出格式**
*输入格式：*
第一行是一个正整数N，表示了序列的长度。

第二行包含N个绝对值不大于10000的整数A[i] ，描述了这段序列。

*输出格式：*
一个整数，为最大的子段和是多少。子段的最小长度为1。

### Q3.5.c 【分析】
分成子段跨越中点和不跨越中点的两个情况

对于跨越中点的，只要找到左边的最大后缀和以及右边的最大前缀和，直接相加就是这种情况下的答案